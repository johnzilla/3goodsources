---
phase: 01-foundation-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - rust-toolchain.toml
  - .env.example
  - src/main.rs
  - src/error.rs
  - src/registry/mod.rs
  - src/registry/types.rs
  - src/registry/error.rs
  - src/mcp/mod.rs
  - src/mcp/error.rs
  - src/pubky/mod.rs
  - src/pubky/error.rs
autonomous: true

must_haves:
  truths:
    - "Project compiles with `cargo build` using Rust edition 2024"
    - "All registry types are defined with strict serde validation"
    - "Module structure matches project convention (registry, mcp, pubky with per-module errors)"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "edition = \"2024\""
    - path: "src/registry/types.rs"
      provides: "Registry, Category, Source, SourceType, Curator type definitions"
      contains: "deny_unknown_fields"
    - path: "src/registry/error.rs"
      provides: "RegistryError enum with thiserror"
      contains: "RegistryError"
    - path: "src/mcp/error.rs"
      provides: "McpError enum placeholder"
      contains: "McpError"
    - path: "src/pubky/error.rs"
      provides: "PubkyError enum placeholder"
      contains: "PubkyError"
  key_links:
    - from: "src/main.rs"
      to: "src/registry/mod.rs"
      via: "mod registry declaration"
      pattern: "mod registry"
    - from: "src/registry/mod.rs"
      to: "src/registry/types.rs"
      via: "pub mod types and re-exports"
      pattern: "pub use types::"
---

<objective>
Scaffold the Rust project with all type definitions, module structure, and dependencies for the 3GS registry server.

Purpose: Establish the foundational project structure and type system that all subsequent plans build on. The registry schema types ARE the protocol -- getting these right is critical.
Output: Compilable Rust project with complete type definitions, error enums, and module hierarchy.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-layer/01-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Rust project with dependencies and module structure</name>
  <files>
    Cargo.toml
    rust-toolchain.toml
    .env.example
    src/main.rs
    src/error.rs
    src/mcp/mod.rs
    src/mcp/error.rs
    src/pubky/mod.rs
    src/pubky/error.rs
  </files>
  <action>
Run `cargo init` in the project root (there's no existing Cargo.toml).

Create `rust-toolchain.toml` pinning to stable channel:
```toml
[toolchain]
channel = "stable"
```

Set up `Cargo.toml` with:
- `name = "three-good-sources"`, edition 2024, rust-version = "1.85"
- Dependencies (use `cargo add` for each):
  - serde (features: derive)
  - serde_json
  - tokio (features: full)
  - thiserror
  - anyhow
  - tracing
  - tracing-subscriber (features: env-filter, json, fmt)
  - dotenvy
  - envy
  - regex

Create `.env.example` with:
```
REGISTRY_PATH=registry.json
LOG_FORMAT=pretty
RUST_LOG=info
```

Create `src/main.rs` as a minimal placeholder that declares all modules and runs:
```rust
mod error;
mod mcp;
mod pubky;
mod registry;

fn main() {
    println!("3GS server - Phase 1 scaffold");
}
```

Create `src/error.rs` as an empty module (placeholder for root error utilities).

Create module stubs:
- `src/mcp/mod.rs`: declares `pub mod error;`
- `src/mcp/error.rs`: defines `McpError` enum with thiserror, single placeholder variant `#[error("MCP not implemented")] NotImplemented`
- `src/pubky/mod.rs`: declares `pub mod error;`
- `src/pubky/error.rs`: defines `PubkyError` enum with thiserror, single placeholder variant `#[error("Pubky not implemented")] NotImplemented`

All error enums use `#[derive(Debug, thiserror::Error)]`.
  </action>
  <verify>Run `cargo build` -- must compile with zero errors. Run `cargo run` -- must print "3GS server - Phase 1 scaffold".</verify>
  <done>Project compiles, all modules declared, dependencies resolved, `cargo build` succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Define registry types with strict serde validation</name>
  <files>
    src/registry/mod.rs
    src/registry/types.rs
    src/registry/error.rs
  </files>
  <action>
Create `src/registry/types.rs` with all registry data types. Every struct gets `#[serde(deny_unknown_fields)]` -- this is a LOCKED decision from CONTEXT.md.

Types to define:

**Registry** (top-level):
- `version: String` -- semver string like "0.1.0"
- `updated: String` -- ISO 8601 date string like "2026-02-01"
- `curator: Curator`
- `endorsements: Vec<Endorsement>` -- required field, can be empty vec
- `categories: HashMap<String, Category>` -- keyed by slug string (e.g., "rust-learning")

Use `HashMap<String, Category>` (not Vec) for categories -- this gives O(1) lookup by slug in later phases and naturally enforces unique slugs. The JSON uses an object with slug keys, not an array.

**Curator**:
- `name: String`
- `pubkey: String` -- placeholder "pk:placeholder" until Phase 5

**Endorsement**:
- Define as an empty struct for now with `deny_unknown_fields`. The endorsements array will be `[]` in v1.

Actually, since endorsements are `Vec<Endorsement>` and the array is empty, just define Endorsement as:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Endorsement {
    // Fields TBD in future phase - empty struct for now
    // Using a struct (not String) so we can add fields later without breaking schema
}
```

Wait -- an empty struct with `deny_unknown_fields` would reject `{}` in JSON since there are no fields to match. But we said endorsements will be `[]` (empty array), so this is fine -- Vec deserialization just produces an empty vec. However, if someone puts `[{}]`, it should also work since Endorsement is an empty struct. Let me reconsider: make Endorsement a placeholder that can accept an object. For now, since the array WILL be empty, a simple empty struct works. But to be safe, skip `deny_unknown_fields` on Endorsement only, since its schema isn't defined yet. Actually the simplest: use `pub endorsements: Vec<serde_json::Value>` so any future shape works. No -- keep it typed. Use the empty struct approach, it's fine since the array is always empty in v1.

**Category**:
- `name: String` -- display name like "Rust Learning"
- `description: String`
- `query_patterns: Vec<String>` -- at least 3 patterns
- `sources: Vec<Source>` -- exactly 3 sources

Note: slug is NOT a field on Category -- it's the HashMap key.

**Source**:
- `rank: u8` -- 1, 2, or 3
- `name: String`
- `url: String`
- `#[serde(rename = "type")] source_type: SourceType`
- `why: String`

**SourceType** (enum):
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    Documentation,
    Tutorial,
    Video,
    Article,
    Tool,
    Repo,
    Forum,
    Book,
    Course,
    Api,
}
```

All types derive: `Debug, Clone, Serialize, Deserialize`. Add `PartialEq` where useful for testing (SourceType, Source, Category).

Create `src/registry/error.rs` with `RegistryError` enum (thiserror):
- `FileRead { path: String, error: String }` -- "Failed to read registry file at {path}: {error}"
- `JsonParse { path: String, error: String, line: usize, column: usize }` -- "Failed to parse registry JSON at {path} (line {line}, column {column}): {error}"
- `DuplicateSlug(String)` -- won't happen with HashMap but keep for explicit validation
- `InvalidSlug { slug: String }` -- "Invalid slug format (must be kebab-case): {slug}"
- `InvalidSourceCount { category: String, expected: usize, actual: usize }` -- "Category '{category}' must have exactly {expected} sources, found {actual}"
- `InsufficientQueryPatterns { category: String, minimum: usize, actual: usize }` -- "Category '{category}' must have at least {minimum} query patterns, found {actual}"
- `InvalidRanks { category: String, actual: Vec<u8> }` -- "Category '{category}' has invalid ranks {actual:?}, expected [1, 2, 3]"

Update `src/registry/mod.rs` to:
- Declare `pub mod types;` and `pub mod error;`
- Re-export key types: `pub use types::{Registry, Category, Source, SourceType, Curator, Endorsement};`
- Re-export error: `pub use error::RegistryError;`
  </action>
  <verify>Run `cargo build` -- must compile with zero errors and zero warnings (add `#[allow(dead_code)]` on types if needed to suppress unused warnings, since nothing uses them yet). Verify all types have `deny_unknown_fields` by grepping: `grep -c "deny_unknown_fields" src/registry/types.rs` should return 5 (Registry, Curator, Endorsement, Category, Source).</verify>
  <done>All registry types compile, use `deny_unknown_fields`, SourceType has all 10 variants, RegistryError has all validation variants. `cargo build` succeeds with no errors.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with no errors
2. `cargo run` executes without panic
3. All modules are declared and compile (registry, mcp, pubky, error)
4. `grep "deny_unknown_fields" src/registry/types.rs` shows annotations on all struct types
5. `grep "RegistryError" src/registry/error.rs` shows all error variants
</verification>

<success_criteria>
- Project compiles on Rust edition 2024 with all dependencies
- Registry types define the complete schema: Registry, Curator, Endorsement, Category, Source, SourceType
- All structs use `#[serde(deny_unknown_fields)]` for strict validation
- Module structure: src/registry/, src/mcp/, src/pubky/, src/error.rs
- Each module has its own error enum using thiserror
- `cargo build` produces zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-01-SUMMARY.md`
</output>
