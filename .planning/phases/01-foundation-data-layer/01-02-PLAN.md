---
phase: 01-foundation-data-layer
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/registry/loader.rs
  - src/registry/mod.rs
  - src/main.rs
  - src/config.rs
  - .gitignore
  - .env
autonomous: true

must_haves:
  truths:
    - "Registry JSON loads from disk into immutable in-memory state on startup"
    - "Missing REGISTRY_PATH env var crashes with clear error message"
    - "Malformed registry.json crashes with specific serde error including line/column"
    - "Invalid business rules (wrong source count, bad slugs) crash with descriptive error"
    - "Successful load logs category count, source count, and registry version"
    - "Logging format switches between pretty (default) and JSON via LOG_FORMAT env var"
  artifacts:
    - path: "src/registry/loader.rs"
      provides: "Async registry loading with file read, JSON parse, and business validation"
      contains: "pub async fn load"
    - path: "src/config.rs"
      provides: "Type-safe config from environment variables"
      contains: "registry_path"
    - path: "src/main.rs"
      provides: "Startup orchestration: config -> logging -> load registry -> log summary"
      contains: "tokio::main"
  key_links:
    - from: "src/main.rs"
      to: "src/config.rs"
      via: "Config::load() call"
      pattern: "Config::load"
    - from: "src/main.rs"
      to: "src/registry/loader.rs"
      via: "registry::load() call"
      pattern: "registry::load"
    - from: "src/registry/loader.rs"
      to: "src/registry/types.rs"
      via: "serde_json::from_str deserializes into Registry type"
      pattern: "serde_json::from_str"
    - from: "src/registry/loader.rs"
      to: "src/registry/error.rs"
      via: "Returns RegistryError on failure"
      pattern: "RegistryError"
---

<objective>
Implement registry loading, business rule validation, environment config, and structured logging for the 3GS startup sequence.

Purpose: This is the core runtime behavior -- load config from env, initialize logging, read registry.json from disk, parse it into typed structs, validate business rules, and log a summary. If anything fails, crash with a clear error.
Output: Working startup binary that loads and validates a registry.json file, with environment-switchable logging.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-data-layer/01-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-RESEARCH.md
@.planning/phases/01-foundation-data-layer/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config loading and structured logging initialization</name>
  <files>
    src/config.rs
    src/main.rs
    .gitignore
    .env
  </files>
  <action>
Create `src/config.rs` with a `Config` struct using `envy` for type-safe env var deserialization:

```rust
use serde::Deserialize;
use std::path::PathBuf;

#[derive(Debug, Deserialize)]
pub struct Config {
    /// Path to registry.json file. Required -- no default.
    pub registry_path: PathBuf,

    /// Logging format: "pretty" (default, colored for dev) or "json" (structured for production).
    #[serde(default = "default_log_format")]
    pub log_format: String,
}

fn default_log_format() -> String {
    "pretty".to_string()
}

impl Config {
    pub fn load() -> Result<Self, anyhow::Error> {
        dotenvy::dotenv().ok(); // Load .env if present, ignore if missing
        envy::from_env::<Config>()
            .map_err(|e| anyhow::anyhow!("Failed to load configuration: {}\n\nRequired: REGISTRY_PATH environment variable must be set", e))
    }
}
```

Create logging initialization function. This can live in `main.rs` or a separate module. Put it in `main.rs` since it's application-level glue:

```rust
fn init_logging(log_format: &str) {
    use tracing_subscriber::{fmt, EnvFilter};

    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));

    match log_format {
        "json" => {
            fmt()
                .json()
                .with_env_filter(env_filter)
                .with_target(false)
                .with_current_span(false)
                .init();
        }
        _ => {
            fmt()
                .pretty()
                .with_env_filter(env_filter)
                .init();
        }
    }
}
```

Update `src/main.rs` to use `#[tokio::main]` and `anyhow::Result`:
1. Load config via `Config::load()?`
2. Initialize logging via `init_logging(&config.log_format)`
3. Log "Starting 3GS server" at info level
4. (Registry loading will be wired in Task 2)
5. For now, just log the config path: `tracing::info!(path = %config.registry_path.display(), "Registry path configured")`

Add `mod config;` to main.rs module declarations.

Create `.gitignore` with:
```
/target
.env
```

Create `.env` file (for local development, gitignored):
```
REGISTRY_PATH=registry.json
LOG_FORMAT=pretty
RUST_LOG=info
```

IMPORTANT: Use `anyhow` ONLY in main.rs (locked decision). Config uses anyhow because it's called from main. The registry module uses its own RegistryError.
  </action>
  <verify>
Run `REGISTRY_PATH=test.json cargo run` -- should print startup log with "Registry path configured" showing "test.json".
Run `cargo run` without REGISTRY_PATH set (and no .env) -- rename .env temporarily, should crash with clear error about missing REGISTRY_PATH.
Run `LOG_FORMAT=json REGISTRY_PATH=test.json cargo run` -- output should be JSON formatted.
  </verify>
  <done>Config loads from env vars, logging initializes in both pretty and JSON modes, missing REGISTRY_PATH produces clear error. `cargo build` succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Implement registry loader with business validation</name>
  <files>
    src/registry/loader.rs
    src/registry/mod.rs
    src/main.rs
  </files>
  <action>
Create `src/registry/loader.rs` with async registry loading:

```rust
pub async fn load(path: &std::path::Path) -> Result<Registry, RegistryError> {
    // 1. Read file asynchronously
    let contents = tokio::fs::read_to_string(path)
        .await
        .map_err(|e| RegistryError::FileRead {
            path: path.display().to_string(),
            error: e.to_string(),
        })?;

    // 2. Parse JSON (from_str is faster than from_reader per serde docs)
    let registry: Registry = serde_json::from_str(&contents)
        .map_err(|e| RegistryError::JsonParse {
            path: path.display().to_string(),
            error: e.to_string(),
            line: e.line(),
            column: e.column(),
        })?;

    // 3. Validate business rules
    validate(&registry)?;

    Ok(registry)
}
```

Implement `validate` function in `loader.rs` (not as a method on Registry -- keep types pure data, logic separate):

```rust
fn validate(registry: &Registry) -> Result<(), RegistryError> {
    let slug_regex = regex::Regex::new(r"^[a-z][a-z0-9]*(-[a-z0-9]+)*$").unwrap();

    for (slug, category) in &registry.categories {
        // Validate kebab-case slug
        if !slug_regex.is_match(slug) {
            return Err(RegistryError::InvalidSlug { slug: slug.clone() });
        }

        // Exactly 3 sources
        if category.sources.len() != 3 {
            return Err(RegistryError::InvalidSourceCount {
                category: slug.clone(),
                expected: 3,
                actual: category.sources.len(),
            });
        }

        // At least 3 query patterns
        if category.query_patterns.len() < 3 {
            return Err(RegistryError::InsufficientQueryPatterns {
                category: slug.clone(),
                minimum: 3,
                actual: category.query_patterns.len(),
            });
        }

        // Ranks must be exactly [1, 2, 3]
        let mut ranks: Vec<u8> = category.sources.iter().map(|s| s.rank).collect();
        ranks.sort_unstable();
        if ranks != vec![1, 2, 3] {
            return Err(RegistryError::InvalidRanks {
                category: slug.clone(),
                actual: category.sources.iter().map(|s| s.rank).collect(),
            });
        }
    }

    Ok(())
}
```

Use `OnceLock` or `lazy_static` for the regex if you prefer, but since this runs once at startup, creating it inline is fine.

Update `src/registry/mod.rs`:
- Add `pub mod loader;` declaration
- Add `pub use loader::load;` re-export

Wire the full startup sequence in `src/main.rs`:

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. Load configuration
    let config = config::Config::load()?;

    // 2. Initialize logging
    init_logging(&config.log_format);
    tracing::info!("Starting 3GS server");

    // 3. Load and validate registry
    tracing::info!(path = %config.registry_path.display(), "Loading registry");
    let registry = registry::load(&config.registry_path)
        .await
        .context("Fatal: failed to load registry at startup")?;

    // 4. Log startup summary
    let total_sources: usize = registry.categories.values().map(|c| c.sources.len()).sum();
    tracing::info!(
        version = %registry.version,
        updated = %registry.updated,
        categories = registry.categories.len(),
        total_sources = total_sources,
        curator = %registry.curator.name,
        "Registry loaded successfully"
    );

    // Phase 1 ends here -- no HTTP server, no MCP protocol
    // The registry is loaded and validated, ready for Phase 2+
    tracing::info!("3GS Phase 1 complete - registry loaded and validated");
    Ok(())
}
```

Add `use anyhow::Context;` at top of main.rs for the `.context()` method.

Create a minimal test fixture at `tests/fixtures/valid_registry.json` with 1 category (3 sources, 3 query patterns) for testing the loader works. This is NOT the real seed data (that's Plan 03). Structure:

```json
{
  "version": "0.1.0",
  "updated": "2026-02-01",
  "curator": {
    "name": "Test Curator",
    "pubkey": "pk:placeholder"
  },
  "endorsements": [],
  "categories": {
    "test-category": {
      "name": "Test Category",
      "description": "A test category for validation",
      "query_patterns": ["test query", "testing things", "how to test"],
      "sources": [
        { "rank": 1, "name": "Source One", "url": "https://example.com/1", "type": "documentation", "why": "First test source" },
        { "rank": 2, "name": "Source Two", "url": "https://example.com/2", "type": "tutorial", "why": "Second test source" },
        { "rank": 3, "name": "Source Three", "url": "https://example.com/3", "type": "article", "why": "Third test source" }
      ]
    }
  }
}
```
  </action>
  <verify>
Run with the test fixture: `REGISTRY_PATH=tests/fixtures/valid_registry.json cargo run` -- must output log lines showing "Loading registry", "Registry loaded successfully" with version, categories=1, total_sources=3, curator="Test Curator".

Test failure modes:
1. `REGISTRY_PATH=nonexistent.json cargo run` -- must crash with "Failed to read registry file" error showing the path.
2. Create a malformed JSON file (e.g., `echo '{bad' > /tmp/bad.json`) and run `REGISTRY_PATH=/tmp/bad.json cargo run` -- must crash with JSON parse error including line/column.
3. Create a JSON with 2 sources in a category and run -- must crash with "must have exactly 3 sources" error.

`cargo build` succeeds with no errors.
  </verify>
  <done>Registry loads from disk, validates business rules (3 sources, 3+ query patterns, ranks 1-2-3, kebab-case slugs), logs startup summary. Missing file crashes with path. Malformed JSON crashes with line/column. Invalid data crashes with specific validation error.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `REGISTRY_PATH=tests/fixtures/valid_registry.json cargo run` loads successfully with startup summary log
3. `REGISTRY_PATH=nonexistent.json cargo run` crashes with file read error
4. `LOG_FORMAT=json REGISTRY_PATH=tests/fixtures/valid_registry.json cargo run` outputs JSON-formatted logs
5. Missing REGISTRY_PATH (no .env, no env var) crashes with clear configuration error
</verification>

<success_criteria>
- Registry loads from disk path specified by REGISTRY_PATH env var
- Missing env var crashes with clear message mentioning REGISTRY_PATH
- Missing file crashes with path and OS error
- Malformed JSON crashes with line/column context
- Business validation rejects: wrong source count, insufficient query patterns, invalid ranks, bad slugs
- Startup logs: "Loading registry", "Registry loaded successfully" with version/categories/sources/curator
- LOG_FORMAT=json switches to JSON structured output
- LOG_FORMAT=pretty (or unset) uses colored pretty output
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-02-SUMMARY.md`
</output>
