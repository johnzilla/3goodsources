---
phase: 01-foundation-data-layer
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - registry.json
autonomous: true

must_haves:
  truths:
    - "All 10 seed categories present with 3 researched sources each"
    - "Running the server loads registry.json and logs 10 categories, 30 sources"
    - "Every source has a real URL, accurate type, and brief why field"
    - "Category slugs are kebab-case, query patterns are natural language agent queries"
  artifacts:
    - path: "registry.json"
      provides: "Complete seed registry with 10 categories and 30 sources"
      contains: "bitcoin-node-setup"
  key_links:
    - from: "src/main.rs"
      to: "registry.json"
      via: "REGISTRY_PATH env var -> registry::load()"
      pattern: "REGISTRY_PATH"
---

<objective>
Create the complete registry.json seed data with 10 curated categories and 30 real, researched sources.

Purpose: The registry IS the product. This file defines what 3GS delivers to agents. Each source must be real, each URL must point to genuinely useful content, and each "why" field must explain what makes this source valuable.
Output: registry.json with 10 categories, 30 sources, validated and loadable by the startup sequence.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-data-layer/01-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create registry.json with 10 seed categories and 30 sources</name>
  <files>registry.json</files>
  <action>
Create `registry.json` at the project root with the following structure. This must conform exactly to the schema defined in Plan 01's types.

Top-level fields:
```json
{
  "version": "0.1.0",
  "updated": "2026-02-01",
  "curator": {
    "name": "3GS Curator",
    "pubkey": "pk:placeholder"
  },
  "endorsements": [],
  "categories": { ... }
}
```

The `categories` field is a JSON object (not array) where keys are kebab-case slugs.

**10 required seed categories** (from PROJECT.md):
1. `bitcoin-node-setup` -- Running a Bitcoin full node
2. `self-hosted-email` -- Self-hosting email servers
3. `rust-learning` -- Learning Rust programming
4. `home-automation-private` -- Privacy-respecting home automation
5. `password-management` -- Password management tools and practices
6. `linux-hardening` -- Linux security hardening
7. `threat-modeling` -- Threat modeling methodologies
8. `nostr-development` -- Developing on the Nostr protocol
9. `pubky-development` -- Developing with Pubky/PKARR
10. `mcp-development` -- Developing MCP servers and clients

For EACH category, provide:
- `name`: Human-readable display name
- `description`: 1-2 sentence description of the topic
- `query_patterns`: At least 3 natural language patterns that an AI agent might use to search for this topic. Think about how users actually phrase questions: "how do I...", "best way to...", "getting started with...", "set up a...", etc.
- `sources`: Exactly 3 sources, ranked 1 (best), 2, 3

For EACH source, provide:
- `rank`: 1, 2, or 3 (1 = best/primary)
- `name`: Display name of the resource
- `url`: REAL URL that resolves to actual content. Use well-known, stable resources:
  - Official documentation sites
  - GitHub repos with 100+ stars
  - Well-established tutorial sites
  - Books from known publishers
  - Conference talks on YouTube from known conferences
- `type`: One of: documentation, tutorial, video, article, tool, repo, forum, book, course, api
- `why`: ONE sentence explaining why this source is recommended. Be specific -- not "good resource" but "step-by-step guide covering initial block download, pruning, and Tor configuration"

**Source selection guidance per category:**

1. **bitcoin-node-setup**: Bitcoin Core docs, a step-by-step guide (like bitcoiner.guide or similar), and a respected tutorial/video. Focus on running your own node, not trading.

2. **self-hosted-email**: Mail-in-a-Box or similar turnkey solution docs, a comprehensive guide (like Ars Technica's email server series or similar), and a tool/repo for mail server setup.

3. **rust-learning**: The Rust Book (official), Rust by Example, and a practical project-based resource (like zero2prod or Rustlings).

4. **home-automation-private**: Home Assistant docs (privacy-focused config), a guide on local-only setup, and a repo/tool for privacy-respecting automation.

5. **password-management**: Bitwarden/KeePassXC docs, a security-focused comparison article, and a guide on password management best practices.

6. **linux-hardening**: CIS Benchmarks or similar official guide, a practical hardening tutorial, and a security tool/repo.

7. **threat-modeling**: OWASP Threat Modeling guide, a practical methodology article, and a tool (like STRIDE or threat modeling tools).

8. **nostr-development**: nostr-protocol repo (NIPs), a getting-started developer guide, and nostr-tools or similar library docs.

9. **pubky-development**: Pubky GitHub org/docs, PKARR specification, and a getting-started resource for Pubky development.

10. **mcp-development**: Anthropic's MCP specification docs, the official MCP SDK repo, and a practical tutorial on building MCP servers.

IMPORTANT CONSTRAINTS:
- URLs must be real and currently accessible (use well-known stable sites)
- Prefer official docs and primary sources over blog posts
- Each category must have EXACTLY 3 sources with ranks 1, 2, 3
- Each category must have at least 3 query_patterns
- `why` fields: one sentence, brief and direct (locked decision from CONTEXT.md)
- Use proper JSON formatting (pretty-printed with 2-space indent for readability)
  </action>
  <verify>
Run the full startup sequence: `REGISTRY_PATH=registry.json cargo run`

Expected output must include log lines showing:
- "Loading registry" with path
- "Registry loaded successfully" with:
  - version = "0.1.0"
  - categories = 10
  - total_sources = 30
  - curator = "3GS Curator"

If it crashes with a validation error, fix the registry.json to match the schema exactly.

Additional checks:
- `cat registry.json | python3 -m json.tool > /dev/null` -- valid JSON
- Count categories: `python3 -c "import json; d=json.load(open('registry.json')); print(len(d['categories']))"` -- must output 10
- Count sources: `python3 -c "import json; d=json.load(open('registry.json')); print(sum(len(c['sources']) for c in d['categories'].values()))"` -- must output 30
  </verify>
  <done>registry.json exists with 10 categories, 30 sources (3 per category). All sources have real URLs, accurate types, and descriptive why fields. `REGISTRY_PATH=registry.json cargo run` loads successfully and logs 10 categories with 30 total sources.</done>
</task>

</tasks>

<verification>
1. `REGISTRY_PATH=registry.json cargo run` completes successfully
2. Log output shows: categories=10, total_sources=30, version="0.1.0"
3. registry.json is valid JSON (parseable by python/jq)
4. All 10 seed category slugs present: bitcoin-node-setup, self-hosted-email, rust-learning, home-automation-private, password-management, linux-hardening, threat-modeling, nostr-development, pubky-development, mcp-development
5. Each category has exactly 3 sources with ranks 1, 2, 3
6. Each category has at least 3 query_patterns
7. Every source has a real URL, valid type, and non-empty why field
</verification>

<success_criteria>
- registry.json contains all 10 seed categories from PROJECT.md
- Every category has exactly 3 sources, ranked 1-2-3
- Every category has at least 3 query_patterns with natural language phrasings
- Every source URL points to a real, known resource
- Every source type is one of the 10 valid enum values
- Every why field is a single descriptive sentence
- `REGISTRY_PATH=registry.json cargo run` loads and validates successfully
- Log output confirms 10 categories and 30 total sources
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md`
</output>
