---
phase: 05-identity-and-provenance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/pubky/mod.rs
  - src/pubky/error.rs
  - src/pubky/identity.rs
  - src/config.rs

autonomous: true

must_haves:
  truths:
    - "generate_or_load_keypair(None) returns a valid Keypair with random keys"
    - "generate_or_load_keypair(Some(valid_hex)) returns Keypair matching that secret key"
    - "generate_or_load_keypair(Some(invalid_hex)) returns descriptive error"
    - "Config loads PKARR_SECRET_KEY as optional field from environment"
  artifacts:
    - path: "src/pubky/identity.rs"
      provides: "generate_or_load_keypair function"
      contains: "pub fn generate_or_load_keypair"
    - path: "src/pubky/error.rs"
      provides: "Identity error variants"
      contains: "InvalidSecretKey"
    - path: "src/config.rs"
      provides: "Optional PKARR_SECRET_KEY config field"
      contains: "pkarr_secret_key"
    - path: "Cargo.toml"
      provides: "pkarr and hex dependencies"
      contains: "pkarr"
  key_links:
    - from: "src/pubky/identity.rs"
      to: "pkarr::Keypair"
      via: "pkarr crate types"
      pattern: "pkarr::Keypair"
    - from: "src/pubky/identity.rs"
      to: "hex crate"
      via: "hex::decode for secret key loading"
      pattern: "hex::decode"
---

<objective>
Create PKARR identity module and add secret key config field.

Purpose: Establish the cryptographic identity foundation — keypair generation and loading from environment — that Plan 02 will wire into the server's AppState, health endpoint, and provenance tool.

Output: Working `generate_or_load_keypair()` function in `src/pubky/identity.rs`, updated `PubkyError` with identity variants, `pkarr_secret_key` field on Config struct, and pkarr + hex dependencies in Cargo.toml.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-identity-and-provenance/05-RESEARCH.md
@src/pubky/mod.rs
@src/pubky/error.rs
@src/config.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pkarr and hex dependencies and create identity module</name>
  <files>
    Cargo.toml
    src/pubky/identity.rs
    src/pubky/mod.rs
    src/pubky/error.rs
  </files>
  <action>
    1. Add dependencies to Cargo.toml under [dependencies]:
       - `pkarr = { version = "5.0", default-features = false }` (minimal features, no DHT/networking)
       - `hex = "0.4"` (hex encoding/decoding for secret keys)

    2. Replace src/pubky/error.rs with proper identity error variants:
       ```rust
       #[derive(Debug, thiserror::Error)]
       pub enum PubkyError {
           #[error("Invalid secret key: {0}")]
           InvalidSecretKey(&'static str),

           #[error("Hex decode error: {0}")]
           HexDecode(#[from] hex::FromHexError),
       }
       ```
       Remove the old `NotImplemented` variant — it is no longer needed.

    3. Create src/pubky/identity.rs with `generate_or_load_keypair` function:
       ```rust
       use pkarr::Keypair;
       use crate::pubky::error::PubkyError;

       /// Generate a new random PKARR keypair or load from a hex-encoded secret key.
       ///
       /// If `secret_key_hex` is Some, decodes the 64-character hex string into 32 bytes
       /// and creates a deterministic keypair. If None, generates a random keypair using
       /// the OS CSPRNG and logs a warning about ephemeral identity.
       pub fn generate_or_load_keypair(secret_key_hex: Option<&str>) -> Result<Keypair, PubkyError> {
           match secret_key_hex {
               Some(hex_str) => {
                   if hex_str.len() != 64 {
                       return Err(PubkyError::InvalidSecretKey(
                           "hex string must be 64 characters (32 bytes)"
                       ));
                   }
                   let bytes = hex::decode(hex_str)?;
                   let mut key_bytes = [0u8; 32];
                   key_bytes.copy_from_slice(&bytes);
                   Ok(Keypair::from_secret_key(&key_bytes))
               }
               None => {
                   tracing::warn!(
                       "PKARR_SECRET_KEY not set, generating ephemeral keypair. \
                        Identity will change on restart."
                   );
                   Ok(Keypair::random())
               }
           }
       }
       ```

    4. Update src/pubky/mod.rs to expose the identity module:
       ```rust
       pub mod error;
       pub mod identity;
       ```

    IMPORTANT: The `pkarr::Keypair::from_secret_key` takes `&[u8; 32]`. Verify the API matches during implementation. If the API differs (e.g., takes `&[u8]` or a different type), adapt accordingly but keep the 32-byte validation.
  </action>
  <verify>
    Run `cargo check` — project must compile with new dependencies and identity module.
    Run `cargo test` — all existing tests must pass (no regressions).
  </verify>
  <done>
    - pkarr and hex appear in Cargo.toml dependencies
    - src/pubky/identity.rs exists with generate_or_load_keypair function
    - PubkyError has InvalidSecretKey and HexDecode variants
    - src/pubky/mod.rs exports both error and identity modules
    - cargo check succeeds, cargo test passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PKARR_SECRET_KEY to Config</name>
  <files>src/config.rs</files>
  <action>
    Add `pkarr_secret_key` as an optional field to the Config struct in src/config.rs:

    ```rust
    /// Optional PKARR secret key (64-char hex string = 32 bytes).
    /// If not set, server generates an ephemeral keypair on startup.
    /// Set via PKARR_SECRET_KEY environment variable for persistent identity.
    pub pkarr_secret_key: Option<String>,
    ```

    This field uses serde's default deserialization for Option — if PKARR_SECRET_KEY env var is not set, envy will deserialize it as None. No #[serde(default)] annotation needed for Option types.

    Do NOT add any validation here — validation happens in generate_or_load_keypair where the hex decoding occurs.
  </action>
  <verify>
    Run `cargo check` — compiles with new Config field.
    Run `cargo test` — all existing tests pass (Config::load works without PKARR_SECRET_KEY set).
  </verify>
  <done>
    - Config struct has pkarr_secret_key: Option<String> field
    - Server starts without PKARR_SECRET_KEY env var (field is None)
    - cargo check succeeds, cargo test passes
  </done>
</task>

</tasks>

<verification>
1. `cargo check` compiles cleanly with pkarr and hex dependencies
2. `cargo test` — all existing tests pass (no regressions)
3. `grep -r "generate_or_load_keypair" src/pubky/identity.rs` finds the function
4. `grep "pkarr_secret_key" src/config.rs` finds the config field
5. `grep "pkarr" Cargo.toml` confirms dependency
</verification>

<success_criteria>
- pkarr and hex dependencies added to Cargo.toml
- generate_or_load_keypair function exists and handles both load-from-env and generate paths
- PubkyError has InvalidSecretKey and HexDecode variants
- Config.pkarr_secret_key is Option<String>
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-identity-and-provenance/05-01-SUMMARY.md`
</output>
