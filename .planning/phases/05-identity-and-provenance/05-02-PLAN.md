---
phase: 05-identity-and-provenance
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/server.rs
  - src/main.rs
  - src/mcp/handler.rs
  - src/mcp/tools.rs

autonomous: true

must_haves:
  truths:
    - "GET /health returns JSON with pubkey field containing a z-base-32 string"
    - "get_provenance tool returns the live server pubkey (not registry.curator.pubkey)"
    - "Server starts without PKARR_SECRET_KEY and logs warning about ephemeral keypair"
    - "Server starts with PKARR_SECRET_KEY and loads deterministic identity"
    - "Server logs pubkey at startup in z-base-32 format"
  artifacts:
    - path: "src/server.rs"
      provides: "AppState with pubkey field, health endpoint returning pubkey"
      contains: "pubkey"
    - path: "src/main.rs"
      provides: "Keypair generation in startup sequence"
      contains: "generate_or_load_keypair"
    - path: "src/mcp/handler.rs"
      provides: "McpHandler with pubkey for tool dispatch"
      contains: "pubkey"
    - path: "src/mcp/tools.rs"
      provides: "get_provenance using live pubkey string"
      contains: "pubkey_z32"
  key_links:
    - from: "src/main.rs"
      to: "src/pubky/identity.rs"
      via: "generate_or_load_keypair call at startup"
      pattern: "generate_or_load_keypair"
    - from: "src/main.rs"
      to: "src/server.rs"
      via: "pubkey passed into AppState"
      pattern: "pubkey"
    - from: "src/mcp/handler.rs"
      to: "src/mcp/tools.rs"
      via: "pubkey_z32 passed to handle_tool_call"
      pattern: "pubkey_z32"
    - from: "src/server.rs"
      to: "health endpoint response"
      via: "state.pubkey in JSON response"
      pattern: "pubkey.*to_z32"
---

<objective>
Wire PKARR public key into server AppState, health endpoint, and get_provenance tool.

Purpose: Complete the identity integration so the server's cryptographic identity is visible in health checks and provenance queries. This is the "last mile" wiring that connects the identity module (Plan 01) to all consumer touchpoints.

Output: Updated AppState with pubkey, health endpoint returning pubkey in z-base-32, get_provenance tool using live pubkey, and main.rs startup sequence generating/loading the keypair.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-identity-and-provenance/05-RESEARCH.md
@.planning/phases/05-identity-and-provenance/05-01-SUMMARY.md
@src/server.rs
@src/main.rs
@src/mcp/handler.rs
@src/mcp/tools.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pubkey to AppState and update health endpoint</name>
  <files>
    src/server.rs
  </files>
  <action>
    1. Add `use pkarr::PublicKey;` import to server.rs.

    2. Add pubkey field to AppState:
       ```rust
       pub struct AppState {
           pub mcp_handler: McpHandler,
           pub registry: Arc<Registry>,
           pub pubkey: PublicKey,  // PublicKey is Copy, no Arc needed
       }
       ```

    3. Update health_endpoint to accept State extractor and include pubkey:
       Change the signature from `async fn health_endpoint()` to:
       ```rust
       async fn health_endpoint(
           State(state): State<Arc<AppState>>,
       ) -> Json<serde_json::Value> {
           Json(json!({
               "status": "ok",
               "version": env!("CARGO_PKG_VERSION"),
               "pubkey": state.pubkey.to_z32()
           }))
       }
       ```

    IMPORTANT: The current health_endpoint does NOT take State. You must add the State extractor parameter.
  </action>
  <verify>
    `cargo check` — compiles with updated AppState and health endpoint.
  </verify>
  <done>
    - AppState has pubkey: PublicKey field
    - health_endpoint returns JSON including "pubkey" field with z-base-32 encoded key
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pubkey through McpHandler and get_provenance tool</name>
  <files>
    src/mcp/handler.rs
    src/mcp/tools.rs
  </files>
  <action>
    The get_provenance tool currently reads `registry.curator.pubkey` (an empty string in registry.json). We need it to use the live server pubkey instead.

    **Strategy:** Store the pubkey z-base-32 string in McpHandler and pass it to tool calls. This avoids importing pkarr types into the MCP layer — just pass a String.

    1. Update McpHandler in src/mcp/handler.rs:
       - Add `pubkey_z32: String` field to McpHandler struct
       - Update `McpHandler::new` to accept pubkey_z32 parameter:
         ```rust
         pub fn new(registry: Arc<Registry>, match_config: MatchConfig, pubkey_z32: String) -> Self {
             Self {
                 initialized: Arc::new(AtomicBool::new(false)),
                 registry,
                 match_config,
                 pubkey_z32,
             }
         }
         ```
       - Pass `&self.pubkey_z32` to `tools::handle_tool_call` in the `handle_tools_call` method:
         ```rust
         match tools::handle_tool_call(
             &call_params.name,
             call_params.arguments,
             &self.registry,
             &self.match_config,
             &self.pubkey_z32,
         )
         ```

    2. Update tools::handle_tool_call in src/mcp/tools.rs:
       - Add `pubkey_z32: &str` parameter to handle_tool_call signature
       - Pass pubkey_z32 to tool_get_provenance
       - Update tool_get_provenance to accept `pubkey_z32: &str` parameter
       - Replace the current `registry.curator.pubkey` fallback logic with:
         ```rust
         let text = format!(
             "Curator: {}\nPublic Key: {}\nRegistry Version: {}\nLast Updated: {}\nEndorsements: {} endorsement(s)\n\nVerification:\nThis registry is curated by {}. Source authenticity can be verified\nusing the PKARR public key above. Each source is manually researched\nand vetted for quality. The registry is cryptographically signed to\nprevent tampering.",
             registry.curator.name,
             pubkey_z32,
             registry.version,
             registry.updated,
             registry.endorsements.len(),
             registry.curator.name
         );
         ```
         Remove the `if registry.curator.pubkey.is_empty()` check — the live pubkey is always available.

    3. Update the test helper `test_handler()` in handler.rs tests:
       - Pass a test pubkey string to McpHandler::new:
         ```rust
         McpHandler::new(Arc::new(registry), match_config, "test-pubkey-z32".to_string())
         ```

    4. Do NOT change tool_get_sources — it still shows `registry.curator.pubkey` in its output, which is fine. The pubkey in get_sources is registry metadata; the pubkey in get_provenance is the live server identity.

    IMPORTANT: The other tool functions (get_sources, list_categories, get_endorsements) do NOT need pubkey_z32. Only pass it to get_provenance.
  </action>
  <verify>
    `cargo check` — compiles with updated handler and tools signatures.
    `cargo test` — all existing tests pass. The get_provenance test should still pass since it checks for "Curator:" and "3GS Curator" which are unchanged.
  </verify>
  <done>
    - McpHandler has pubkey_z32: String field
    - McpHandler::new accepts pubkey_z32 parameter
    - handle_tool_call passes pubkey_z32 to get_provenance
    - get_provenance uses live pubkey_z32 instead of registry.curator.pubkey
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire keypair generation into main.rs startup</name>
  <files>
    src/main.rs
  </files>
  <action>
    Update src/main.rs startup sequence to generate/load PKARR keypair and pass pubkey into AppState and McpHandler.

    After `let config = Config::load()?;` and before building McpHandler, add:

    ```rust
    // Generate or load PKARR keypair for server identity
    let keypair = crate::pubky::identity::generate_or_load_keypair(
        config.pkarr_secret_key.as_deref()
    )?;
    let public_key = keypair.public_key();
    tracing::info!(
        pubkey = %public_key.to_z32(),
        "Server identity initialized"
    );
    ```

    The placement should be AFTER logging is initialized (so the warning in generate_or_load_keypair is visible) but BEFORE McpHandler construction.

    Suggested order in main():
    1. Config::load
    2. init_logging
    3. info "Starting 3GS server"
    4. MatchConfig::load + validate
    5. generate_or_load_keypair  <-- NEW
    6. Registry load
    7. McpHandler::new (now passes pubkey_z32)
    8. AppState (now includes pubkey)
    9. Router + serve

    Update the McpHandler::new call to pass the pubkey z32 string:
    ```rust
    let pubkey_z32 = public_key.to_z32();
    let mcp_handler = mcp::McpHandler::new(Arc::clone(&registry), match_config, pubkey_z32);
    ```

    Update the AppState construction to include pubkey:
    ```rust
    let app_state = Arc::new(server::AppState {
        mcp_handler,
        registry,
        pubkey: public_key,
    });
    ```

    Add `use pkarr::PublicKey;` is NOT needed in main.rs — the type is inferred from keypair.public_key() return.
  </action>
  <verify>
    `cargo check` — compiles with full wiring.
    `cargo test` — all tests pass.
    `cargo build` — successful build.

    Manual verification (if time permits):
    - Start server without PKARR_SECRET_KEY: should log warning about ephemeral keypair and log the pubkey.
    - `curl http://localhost:3000/health` should return JSON with "pubkey" field containing z-base-32 string.
  </verify>
  <done>
    - main.rs calls generate_or_load_keypair during startup
    - Public key logged at startup in z-base-32 format
    - pubkey_z32 passed to McpHandler::new
    - public_key stored in AppState
    - Server compiles and all tests pass
  </done>
</task>

</tasks>

<verification>
1. `cargo build` — full project compiles
2. `cargo test` — all tests pass (no regressions)
3. Start server without PKARR_SECRET_KEY:
   - Log output contains "PKARR_SECRET_KEY not set, generating ephemeral keypair"
   - Log output contains "Server identity initialized" with pubkey
4. `curl http://localhost:3000/health` returns JSON with status, version, AND pubkey fields
5. Send get_provenance tool call via /mcp endpoint — response includes a z-base-32 public key (not "Not yet configured")
6. Start server WITH PKARR_SECRET_KEY=<64-char-hex>:
   - No warning about ephemeral keypair
   - Same pubkey appears consistently across restarts
</verification>

<success_criteria>
- Health endpoint returns pubkey in z-base-32 format
- get_provenance tool returns the live server pubkey
- Ephemeral keypair generates with warning when no PKARR_SECRET_KEY set
- Persistent keypair loads from PKARR_SECRET_KEY when set
- Server identity logged at startup
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/05-identity-and-provenance/05-02-SUMMARY.md`
</output>
