---
phase: 07-documentation-testing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [Cargo.toml, src/lib.rs, tests/common/mod.rs, tests/integration_registry.rs]
autonomous: true

must_haves:
  truths:
    - "reqwest is in dev-dependencies for HTTP integration tests"
    - "lib.rs exports server module (AppState, build_router) for integration test access"
    - "Shared test helper spawns a real HTTP server on random port"
    - "Registry loading tests confirm correct parsing and validation of real registry.json"
    - "Registry endpoint returns all expected categories with 3 sources each"
  artifacts:
    - path: "Cargo.toml"
      provides: "reqwest in dev-dependencies"
      contains: "reqwest"
    - path: "src/lib.rs"
      provides: "Public API surface for integration tests"
      contains: "pub mod server"
    - path: "tests/common/mod.rs"
      provides: "spawn_test_server helper function"
      min_lines: 20
    - path: "tests/integration_registry.rs"
      provides: "Registry loading and validation integration tests"
      min_lines: 40
  key_links:
    - from: "tests/common/mod.rs"
      to: "src/server.rs"
      via: "imports build_router and AppState"
      pattern: "three_good_sources::server"
    - from: "tests/integration_registry.rs"
      to: "tests/common/mod.rs"
      via: "mod common import"
      pattern: "mod common"
---

<objective>
Set up test infrastructure (reqwest dependency, lib.rs public exports, shared test helper) and implement registry loading integration tests.

Purpose: Integration tests need access to the server's public API through lib.rs, a shared helper to spawn real HTTP servers on random ports, and reqwest for making real HTTP requests. Registry tests validate that the actual registry.json loads correctly and serves expected data through the /registry endpoint.

Output: Updated Cargo.toml, updated lib.rs, tests/common/mod.rs, tests/integration_registry.rs
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@Cargo.toml
@src/lib.rs
@src/server.rs
@src/main.rs
@src/config.rs
@src/mcp/handler.rs
@src/matcher/config.rs
@src/matcher/mod.rs
@src/pubky/identity.rs
@src/registry/types.rs
@src/registry/loader.rs
@registry.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reqwest dev-dependency and update lib.rs exports</name>
  <files>Cargo.toml, src/lib.rs</files>
  <action>
**Cargo.toml:** Add reqwest to [dev-dependencies]:
```toml
[dev-dependencies]
approx = "0.5"
reqwest = { version = "0.12", features = ["json"] }
```

Note: Use reqwest 0.12 (the latest stable line compatible with tokio 1.x and hyper 1.x). Check the project's axum 0.8 dependency -- axum 0.8 uses hyper 1.x, so reqwest 0.12 is the correct match.

**src/lib.rs:** The current lib.rs only exports modules with `pub mod`. But `server` module is NOT listed (it's only in main.rs as `mod server`). Integration tests need access to `AppState`, `build_router`, and other types. Update lib.rs to export everything integration tests need:

```rust
pub mod config;
pub mod error;
pub mod matcher;
pub mod mcp;
pub mod pubky;
pub mod registry;
pub mod server;
```

This adds `pub mod server` so integration tests can use `three_good_sources::server::AppState` and `three_good_sources::server::build_router`.

IMPORTANT: The main.rs currently uses `mod server;` (private). It also uses `mod config;`, `mod matcher;`, etc. Since lib.rs already exports these publicly, main.rs is a binary crate with its own module tree. This is fine -- main.rs has its own `mod` declarations, and lib.rs has `pub mod` declarations. Both work because Cargo treats them as separate crate roots. Do NOT change main.rs.
  </action>
  <verify>
- `grep "reqwest" Cargo.toml` shows reqwest in dev-dependencies
- `grep "pub mod server" src/lib.rs` shows server module exported
- `cargo check` compiles successfully
- `cargo check --tests` compiles with test dependencies
  </verify>
  <done>
reqwest 0.12 is in dev-dependencies. lib.rs exports server module publicly. Both `cargo check` and `cargo check --tests` pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test helper and registry integration tests</name>
  <files>tests/common/mod.rs, tests/integration_registry.rs</files>
  <action>
**tests/common/mod.rs:** Create shared test helper that spawns a real HTTP server:

```rust
use three_good_sources::matcher::MatchConfig;
use three_good_sources::mcp::McpHandler;
use three_good_sources::pubky::identity::generate_or_load_keypair;
use three_good_sources::registry::Registry;
use three_good_sources::server::{AppState, build_router};
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::TcpListener;

/// Spawn a real HTTP server on a random port for integration testing.
/// Returns the socket address for making requests.
pub async fn spawn_test_server() -> SocketAddr {
    // Load real registry from project root
    let registry_json = include_str!("../registry.json");
    let registry: Registry = serde_json::from_str(registry_json)
        .expect("Failed to parse registry.json");
    let registry = Arc::new(registry);

    // Default match config
    let match_config = MatchConfig {
        match_threshold: 0.4,
        match_fuzzy_weight: 0.7,
        match_keyword_weight: 0.3,
    };

    // Generate ephemeral keypair for testing
    let keypair = generate_or_load_keypair(None)
        .expect("Failed to generate test keypair");
    let pubkey = keypair.public_key();
    let pubkey_z32 = pubkey.to_z32();

    // Build MCP handler and app state
    let mcp_handler = McpHandler::new(Arc::clone(&registry), match_config, pubkey_z32);
    let app_state = Arc::new(AppState {
        mcp_handler,
        registry,
        pubkey,
    });

    let app = build_router(app_state);

    // Bind to port 0 - OS assigns random available port
    let listener = TcpListener::bind("127.0.0.1:0").await
        .expect("Failed to bind to port 0");
    let addr = listener.local_addr().unwrap();

    // Spawn server in background task
    tokio::spawn(async move {
        axum::serve(listener, app).await.unwrap();
    });

    // Brief pause to ensure server is listening
    tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;

    addr
}
```

Key design choices:
- Uses `include_str!` to load registry.json at compile time (no file system dependency at test runtime)
- Generates ephemeral keypair (no PKARR_SECRET_KEY needed)
- Returns only SocketAddr (tests construct their own reqwest::Client)
- 10ms sleep prevents connection-refused race condition

**tests/integration_registry.rs:** Registry loading and validation integration tests (TEST-04):

```rust
mod common;

use serde_json::Value;

#[tokio::test]
async fn test_registry_endpoint_returns_200() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    assert_eq!(response.status(), 200);
}

#[tokio::test]
async fn test_registry_has_expected_categories() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    let registry: Value = response.json().await.unwrap();
    let categories = registry["categories"].as_object().unwrap();

    // Assert specific seed categories exist
    assert!(categories.contains_key("rust-learning"), "Missing rust-learning");
    assert!(categories.contains_key("bitcoin-node-setup"), "Missing bitcoin-node-setup");
    assert!(categories.contains_key("self-hosted-email"), "Missing self-hosted-email");
    assert!(categories.contains_key("home-automation-private"), "Missing home-automation-private");
    assert!(categories.contains_key("password-management"), "Missing password-management");
    assert!(categories.contains_key("linux-hardening"), "Missing linux-hardening");
    assert!(categories.contains_key("threat-modeling"), "Missing threat-modeling");
    assert!(categories.contains_key("nostr-development"), "Missing nostr-development");
    assert!(categories.contains_key("pubky-development"), "Missing pubky-development");
    assert!(categories.contains_key("mcp-development"), "Missing mcp-development");
    assert_eq!(categories.len(), 10, "Should have exactly 10 categories");
}

#[tokio::test]
async fn test_each_category_has_three_sources() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    let registry: Value = response.json().await.unwrap();
    let categories = registry["categories"].as_object().unwrap();

    for (slug, category) in categories {
        let sources = category["sources"].as_array()
            .unwrap_or_else(|| panic!("Category {} missing sources array", slug));
        assert_eq!(sources.len(), 3, "Category {} should have exactly 3 sources", slug);
    }
}

#[tokio::test]
async fn test_sources_have_valid_structure() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    let registry: Value = response.json().await.unwrap();
    let categories = registry["categories"].as_object().unwrap();

    for (slug, category) in categories {
        let sources = category["sources"].as_array().unwrap();
        for source in sources {
            assert!(source["rank"].is_number(), "{}: source missing rank", slug);
            assert!(source["name"].is_string(), "{}: source missing name", slug);
            assert!(source["url"].as_str().unwrap().starts_with("http"), "{}: source URL invalid", slug);
            assert!(source["type"].is_string(), "{}: source missing type", slug);
            assert!(source["why"].as_str().unwrap().len() > 10, "{}: source 'why' too short", slug);
        }
    }
}

#[tokio::test]
async fn test_sources_have_sequential_ranks() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    let registry: Value = response.json().await.unwrap();
    let categories = registry["categories"].as_object().unwrap();

    for (slug, category) in categories {
        let sources = category["sources"].as_array().unwrap();
        let mut ranks: Vec<u64> = sources.iter()
            .map(|s| s["rank"].as_u64().unwrap())
            .collect();
        ranks.sort();
        assert_eq!(ranks, vec![1, 2, 3], "Category {} should have ranks 1,2,3", slug);
    }
}

#[tokio::test]
async fn test_registry_has_version_and_curator() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/registry", addr))
        .await
        .unwrap();
    let registry: Value = response.json().await.unwrap();

    assert!(registry["version"].is_string(), "Missing version");
    assert!(registry["curator"]["name"].is_string(), "Missing curator name");
    assert!(registry["curator"]["pubkey"].is_string(), "Missing curator pubkey");
    assert!(registry["updated"].is_string(), "Missing updated date");
}

#[tokio::test]
async fn test_health_endpoint_returns_status_ok() {
    let addr = common::spawn_test_server().await;
    let response = reqwest::get(format!("http://{}/health", addr))
        .await
        .unwrap();
    assert_eq!(response.status(), 200);

    let body: Value = response.json().await.unwrap();
    assert_eq!(body["status"], "ok");
    assert!(body["version"].is_string(), "Missing version");
    assert!(body["pubkey"].is_string(), "Missing pubkey");
    // Pubkey should be z-base-32 (52 chars)
    let pubkey = body["pubkey"].as_str().unwrap();
    assert!(pubkey.len() > 40, "Pubkey too short: {}", pubkey);
}
```

These tests validate TEST-04 (registry loading) plus health endpoint basics using real HTTP requests against a real server.
  </action>
  <verify>
- `cargo test --test integration_registry` runs all registry integration tests
- All tests pass (exit code 0)
- `grep "spawn_test_server" tests/common/mod.rs` confirms helper exists
- `grep "#\[tokio::test\]" tests/integration_registry.rs | wc -l` shows 7 test functions
  </verify>
  <done>
Test infrastructure is in place: reqwest in dev-deps, lib.rs exports server module, tests/common/mod.rs has spawn_test_server helper, and 7 registry integration tests pass validating real registry.json data through real HTTP requests.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --tests` -- entire project compiles including test code
2. `cargo test --test integration_registry` -- all registry tests pass
3. `cargo test` -- existing inline tests still pass alongside new integration tests
</verification>

<success_criteria>
Test infrastructure enables integration tests to spawn real HTTP servers on random ports. Registry integration tests validate that all 10 seed categories exist, each has 3 sources with valid structure and sequential ranks, and health endpoint returns expected fields -- all through real HTTP requests.
</success_criteria>

<output>
After completion, create `.planning/phases/07-documentation-testing/07-03-SUMMARY.md`
</output>
