---
phase: 06-infrastructure-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - Cargo.toml
  - render.yaml
autonomous: true
user_setup:
  - service: render
    why: "Production hosting for Docker container"
    env_vars:
      - name: PKARR_SECRET_KEY
        source: "Generate with: openssl rand -hex 32, then set in Render Dashboard > Environment"
    dashboard_config:
      - task: "Create web service from repo"
        location: "Render Dashboard > New > Web Service"
      - task: "Add custom domain api.3gs.ai"
        location: "Render Dashboard > Service > Settings > Custom Domains"

must_haves:
  truths:
    - "docker build produces a working image under 50MB"
    - "Docker container runs and responds to MCP requests on port 3000"
    - "render.yaml declares correct environment variables, health check, and disk mount"
    - "Release binary is size-optimized with LTO and symbol stripping"
  artifacts:
    - path: "Dockerfile"
      provides: "Three-stage cargo-chef build with non-root runtime user"
      contains: "cargo chef"
    - path: ".dockerignore"
      provides: "Build context exclusions for fast, secure builds"
      contains: "target/"
    - path: "render.yaml"
      provides: "Render Blueprint for declarative deployment"
      contains: "healthCheckPath"
    - path: "Cargo.toml"
      provides: "Release profile with size optimizations"
      contains: "opt-level"
  key_links:
    - from: "Dockerfile"
      to: "Cargo.toml"
      via: "cargo build --release reads release profile"
      pattern: "cargo.*--release"
    - from: "render.yaml"
      to: "Dockerfile"
      via: "runtime: docker triggers Docker build on Render"
      pattern: "runtime: docker"
    - from: "render.yaml"
      to: "src/server.rs"
      via: "healthCheckPath: /health matches GET /health endpoint"
      pattern: "healthCheckPath.*health"
---

<objective>
Create Docker build infrastructure and Render deployment configuration for the 3GS MCP server.

Purpose: Enable containerized deployment of the Rust MCP server to Render's paid tier with proper dependency caching, size optimization, and declarative infrastructure configuration.

Output: Dockerfile (multi-stage with cargo-chef), .dockerignore, Cargo.toml release profile, and render.yaml Blueprint.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-deployment/06-CONTEXT.md
@.planning/phases/06-infrastructure-deployment/06-RESEARCH.md
@Cargo.toml
@src/main.rs
@src/config.rs
@src/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile, .dockerignore, and release profile</name>
  <files>Dockerfile, .dockerignore, Cargo.toml</files>
  <action>
Create three-stage Dockerfile using cargo-chef for dependency caching:

**Stage 1 - Planner:**
- FROM lukemathwalker/cargo-chef:latest-rust-1.84 AS planner
- WORKDIR /app
- COPY Cargo.toml Cargo.lock ./
- COPY src/ src/ (cargo-chef needs source structure to analyze dependencies)
- RUN cargo chef prepare --recipe-path recipe.json

NOTE on Rust version: Cargo.toml says rust-version = "1.85" and rust-toolchain.toml says channel = "stable". The cargo-chef image pins rust:1.84. This is fine — rust-version is minimum supported, not required exact. If the build fails on 1.84, switch to lukemathwalker/cargo-chef:latest-rust-1.85 for all stages.

**Stage 2 - Builder:**
- FROM lukemathwalker/cargo-chef:latest-rust-1.84 AS builder (MUST match planner version)
- WORKDIR /app
- COPY --from=planner /app/recipe.json recipe.json
- RUN with cache mounts for cargo registry and git: cargo chef cook --release --recipe-path recipe.json
- COPY . . (full source after dependencies cached)
- RUN with cache mounts: cargo build --release --bin three-good-sources

**Stage 3 - Runtime:**
- FROM debian:bookworm-slim AS runtime
- RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
- Create non-root user: groupadd -g 1001 appgroup && useradd -u 1001 -g appgroup -m -d /home/appuser appuser
- COPY --from=builder --chown=appuser:appgroup /app/target/release/three-good-sources /usr/local/bin/app
- Also COPY registry.json into image as fallback: COPY --chown=appuser:appgroup registry.json /app/registry.json
  (Research recommends baking registry.json for initial deploy; Render disk mount overrides at /data/registry.json)
- USER appuser
- EXPOSE 3000
- ENV REGISTRY_PATH=/app/registry.json
- ENTRYPOINT ["/usr/local/bin/app"]

**Create .dockerignore** with these exclusions:
- target/
- .git/
- .gitignore
- .planning/
- .env
- .env.*
- *.swp, *.swo, *~
- README.md
- LICENSE
- docs/
- tests/

**Add release profile to Cargo.toml** (append after [dev-dependencies]):
```toml
[profile.release]
opt-level = "z"
lto = "fat"
codegen-units = 1
panic = "abort"
strip = "symbols"
```

Do NOT remove existing Cargo.toml content — only append the release profile section.
Do NOT include Cargo.lock in .dockerignore (it's needed for reproducible builds).
  </action>
  <verify>
Run: docker build -t three-good-sources .
Build must complete without errors. Check image size with: docker images three-good-sources --format "{{.Size}}"
  </verify>
  <done>Dockerfile builds successfully. Image is under 50MB. .dockerignore excludes target/, .git/, .env, .planning/. Cargo.toml has release profile with opt-level "z", lto "fat", strip "symbols".</done>
</task>

<task type="auto">
  <name>Task 2: Create render.yaml deployment Blueprint</name>
  <files>render.yaml</files>
  <action>
Create render.yaml in project root with Render Blueprint specification:

```yaml
services:
  - type: web
    name: three-good-sources-api
    runtime: docker
    region: oregon
    plan: starter
    branch: main
    healthCheckPath: /health
    autoDeploy: true
    envVars:
      - key: REGISTRY_PATH
        value: /data/registry.json
      - key: LOG_FORMAT
        value: json
      - key: PORT
        value: "3000"
      - key: RUST_LOG
        value: info
      - key: PKARR_SECRET_KEY
        sync: false
    disk:
      name: registry-data
      mountPath: /data
      sizeGB: 1
```

Key points:
- plan: starter (paid tier per CONTEXT.md — no spin-down)
- healthCheckPath: /health (matches existing GET /health endpoint in server.rs)
- REGISTRY_PATH: /data/registry.json (persistent disk mount overrides baked-in fallback)
- PKARR_SECRET_KEY with sync: false (Render prompts once, stores securely — never in YAML)
- PORT as string "3000" (Render passes env vars as strings)
- disk mount at /data with 1GB (ample for registry.json)
- autoDeploy: true (push to main triggers deploy)

The Dockerfile's ENV REGISTRY_PATH=/app/registry.json provides fallback if /data/registry.json doesn't exist yet.
The render.yaml REGISTRY_PATH=/data/registry.json overrides it once disk is populated.
  </action>
  <verify>
Validate YAML syntax: python3 -c "import yaml; yaml.safe_load(open('render.yaml'))" or similar.
Check render.yaml contains: healthCheckPath, envVars with all 5 keys, disk section with mountPath /data.
  </verify>
  <done>render.yaml exists with correct service type (web), runtime (docker), plan (starter), health check (/health), all 5 env vars, and persistent disk mount at /data.</done>
</task>

</tasks>

<verification>
1. `docker build -t three-good-sources .` completes successfully
2. `docker images three-good-sources --format "{{.Size}}"` shows image under 50MB
3. `docker run --rm -e REGISTRY_PATH=/app/registry.json -p 3000:3000 three-good-sources` starts server
4. `curl http://localhost:3000/health` returns JSON with status, version, and pubkey
5. `curl -X POST http://localhost:3000/mcp -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1.0"}},"id":1}'` returns MCP initialize response
6. render.yaml passes YAML lint
7. Cargo.toml [profile.release] section present with opt-level, lto, strip settings
</verification>

<success_criteria>
- Docker image builds from Dockerfile in under 10 minutes (first build)
- Docker image size is under 50MB
- Container runs and serves MCP requests on port 3000
- render.yaml is valid and declares all required configuration
- .dockerignore excludes sensitive and unnecessary files
- Binary is size-optimized via release profile
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-deployment/06-01-SUMMARY.md`
</output>
