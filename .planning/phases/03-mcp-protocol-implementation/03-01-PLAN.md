---
phase: 03-mcp-protocol-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/mcp/mod.rs
  - src/mcp/error.rs
  - src/mcp/types.rs
  - src/mcp/handler.rs
autonomous: true

must_haves:
  truths:
    - "initialize method returns protocolVersion 2025-11-25, serverInfo with name and version, and capabilities with tools"
    - "Requests before initialize return JSON-RPC error -32002 with not initialized message"
    - "Notifications (no id field) are silently ignored with no response"
    - "Batch requests (JSON array) return JSON-RPC error -32600"
    - "Unknown methods return JSON-RPC error -32601"
    - "All responses include jsonrpc: 2.0 field"
    - "Invalid JSON returns parse error -32700"
  artifacts:
    - path: "src/mcp/types.rs"
      provides: "JSON-RPC 2.0 message types and MCP protocol types"
      contains: "JsonRpcRequest"
    - path: "src/mcp/handler.rs"
      provides: "McpHandler with init state tracking, batch rejection, dispatch, and initialize handler"
      exports: ["McpHandler"]
    - path: "src/mcp/error.rs"
      provides: "McpError enum with protocol-level error variants"
      contains: "McpError"
    - path: "src/mcp/mod.rs"
      provides: "Module re-exports for mcp subsystem"
  key_links:
    - from: "src/mcp/handler.rs"
      to: "src/mcp/types.rs"
      via: "Uses JsonRpcRequest/JsonRpcResponse for protocol handling"
      pattern: "JsonRpcRequest"
    - from: "src/mcp/handler.rs"
      to: "src/registry/types.rs"
      via: "Holds Arc<Registry> for tool access"
      pattern: "Arc<Registry>"
    - from: "src/mcp/handler.rs"
      to: "src/matcher/mod.rs"
      via: "Holds MatchConfig for query matching"
      pattern: "MatchConfig"
---

<objective>
Create MCP protocol foundation: JSON-RPC 2.0 types, handler with initialize handshake, batch rejection, notification handling, and method dispatch routing.

Purpose: Establishes the protocol layer that tool implementations (Plan 02) build on. This is the JSON-RPC envelope handling, not the tool logic.
Output: Working McpHandler that passes protocol compliance tests (init, batch, notifications, routing, error codes).
</objective>

<execution_context>
@/home/john/.claude/agents/gsd-planner.md
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-protocol-implementation/03-CONTEXT.md
@.planning/phases/03-mcp-protocol-implementation/03-RESEARCH.md
@src/registry/types.rs
@src/matcher/mod.rs
@src/matcher/config.rs
@src/mcp/mod.rs
@src/mcp/error.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schemars dependency and create MCP types and error enum</name>
  <files>
    Cargo.toml
    src/mcp/types.rs
    src/mcp/error.rs
  </files>
  <action>
    1. Add schemars dependency to Cargo.toml:
       `schemars = { version = "1", features = ["derive"] }` under [dependencies]

    2. Replace placeholder `src/mcp/error.rs` with proper McpError enum (thiserror):
       - `ParseError(String)` — JSON parsing failed
       - `SerializationError(String)` — Response serialization failed
       - Keep consistent with project pattern (per-module error enums, thiserror)

    3. Create `src/mcp/types.rs` with all JSON-RPC 2.0 and MCP protocol types:

       **JSON-RPC types (all with #[serde(deny_unknown_fields)] per project standard):**

       `JsonRpcRequest`:
       - `jsonrpc: String` — must be "2.0"
       - `id: Option<serde_json::Value>` — absent means notification
       - `method: String`
       - `params: Option<serde_json::Value>` — optional, skip_serializing_if None

       `JsonRpcResponse`:
       - `jsonrpc: String` — always "2.0"
       - `id: serde_json::Value`
       - `result: Option<serde_json::Value>` — skip_serializing_if None
       - `error: Option<JsonRpcError>` — skip_serializing_if None

       `JsonRpcError`:
       - `code: i32`
       - `message: String`
       - `data: Option<serde_json::Value>` — skip_serializing_if None

       **Convenience constructors on JsonRpcResponse (implement as methods):**
       - `fn success(id: Value, result: Value) -> Self` — wraps result in success response
       - `fn error(id: Value, code: i32, message: String) -> Self` — wraps in error response
       - `fn parse_error() -> Self` — code -32700, "Parse error", id: Value::Null
       - `fn invalid_request() -> Self` — code -32600, "Invalid request", id: Value::Null
       - `fn method_not_found(id: Value) -> Self` — code -32601, "Method not found"
       - `fn invalid_params(id: Value) -> Self` — code -32602, "Invalid params"
       - `fn not_initialized(id: Value) -> Self` — code -32002, "Server not initialized. Call initialize first."
       - `fn tool_result(id: Value, text: String, is_error: bool) -> Self` — MCP content result format: `{ content: [{ type: "text", text: ... }], isError: ... }`

       **MCP Initialize types:**

       `InitializeParams` (#[serde(deny_unknown_fields)]):
       - `protocol_version: String` with `#[serde(rename = "protocolVersion")]`
       - `capabilities: serde_json::Value` — accept any client capabilities (we don't use them)
       - `client_info: serde_json::Value` with `#[serde(rename = "clientInfo")]` — accept any client info

       NOTE on InitializeParams: Do NOT use deny_unknown_fields here. The MCP spec may send additional fields in initialize that we don't model. Use deny_unknown_fields only on OUR input types (tool params). For InitializeParams, just derive Deserialize without deny_unknown_fields to be forward-compatible with spec changes.

       `CallToolParams` (#[serde(deny_unknown_fields)]):
       - `name: String`
       - `arguments: Option<serde_json::Value>` — skip_serializing_if None

       **JSON-RPC error codes as constants:**
       ```rust
       pub const PARSE_ERROR: i32 = -32700;
       pub const INVALID_REQUEST: i32 = -32600;
       pub const METHOD_NOT_FOUND: i32 = -32601;
       pub const INVALID_PARAMS: i32 = -32602;
       pub const NOT_INITIALIZED: i32 = -32002;
       ```
  </action>
  <verify>
    Run `cargo check` — project compiles with new types and schemars dependency.
  </verify>
  <done>
    - schemars added to Cargo.toml with derive feature
    - McpError has ParseError and SerializationError variants
    - JsonRpcRequest, JsonRpcResponse, JsonRpcError types defined with serde derives
    - All convenience constructors implemented (success, error, parse_error, invalid_request, method_not_found, invalid_params, not_initialized, tool_result)
    - InitializeParams and CallToolParams defined
    - Error code constants defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Create handler with init handshake, dispatch, and protocol tests</name>
  <files>
    src/mcp/handler.rs
    src/mcp/mod.rs
  </files>
  <action>
    1. Create `src/mcp/handler.rs` with McpHandler struct:

       ```rust
       pub struct McpHandler {
           initialized: Arc<AtomicBool>,
           registry: Arc<Registry>,
           match_config: MatchConfig,
       }
       ```

       Constructor: `McpHandler::new(registry: Arc<Registry>, match_config: MatchConfig) -> Self`
       Sets initialized to false.

    2. Implement `pub fn handle_json(&self, raw_json: &str) -> Option<String>`:
       This is the main entry point. Returns Option because notifications produce no response.

       Flow:
       a. Parse raw JSON into serde_json::Value. If parse fails -> return Some(JsonRpcResponse::parse_error() serialized).
       b. Check if parsed value is array -> return Some(JsonRpcResponse::invalid_request() serialized with message "Batch requests not supported").
       c. Deserialize Value into JsonRpcRequest. If fails -> return Some(JsonRpcResponse::parse_error() serialized).
       d. Validate jsonrpc field is exactly "2.0". If not -> return Some(JsonRpcResponse::invalid_request() serialized).
       e. Check if request has id (is it a notification?). If no id -> return None (silently ignore).
       f. Extract id (unwrap the Option since we checked above).
       g. Check init gate: if method is NOT "initialize" AND initialized is false -> return Some(JsonRpcResponse::not_initialized(id) serialized).
       h. Dispatch on method:
          - "initialize" -> handle_initialize(id, params)
          - "notifications/initialized" -> None (it's a client notification, ignore)
          - "tools/list" -> placeholder that returns method_not_found for now (Plan 02 implements)
          - "tools/call" -> placeholder that returns method_not_found for now (Plan 02 implements)
          - _ -> Some(JsonRpcResponse::method_not_found(id) serialized)

    3. Implement `fn handle_initialize(&self, id: Value, params: Option<Value>) -> Option<String>`:
       - Deserialize params into InitializeParams. If fails -> return Some(invalid_params response).
       - Set initialized flag to true (store with Ordering::SeqCst).
       - Return success response with:
         ```json
         {
           "protocolVersion": "2025-11-25",
           "capabilities": { "tools": {} },
           "serverInfo": {
             "name": "three-good-sources",
             "version": env!("CARGO_PKG_VERSION")
           }
         }
         ```

    4. Add stub methods that Plan 02 will implement (return method_not_found for now):
       - `fn handle_tools_list(&self, id: Value, params: Option<Value>) -> Option<String>`
       - `fn handle_tools_call(&self, id: Value, params: Option<Value>) -> Option<String>`

    5. Update `src/mcp/mod.rs`:
       - Add `pub mod types;` and `pub mod handler;`
       - Re-export key types: `pub use handler::McpHandler;`
       - Keep `pub mod error;`

    6. Add comprehensive tests in `#[cfg(test)] mod tests` at bottom of handler.rs:

       Test helper: Create a `test_handler()` function that loads registry.json with `include_str!("../../registry.json")`, creates default MatchConfig (threshold=0.4, fuzzy=0.7, keyword=0.3), and returns McpHandler::new(...).

       Tests:
       a. `test_initialize_returns_protocol_version` — send initialize request, verify response has protocolVersion "2025-11-25", capabilities.tools exists, serverInfo.name is "three-good-sources"
       b. `test_initialize_sets_initialized_flag` — after initialize, handler.initialized should be true
       c. `test_pre_init_tools_list_rejected` — send tools/list without init -> error -32002
       d. `test_pre_init_tools_call_rejected` — send tools/call without init -> error -32002
       e. `test_batch_request_rejected` — send JSON array `[{...}]` -> error -32600 with "Batch requests not supported"
       f. `test_notification_returns_none` — send request with no id field -> handle_json returns None
       g. `test_unknown_method_returns_error` — send unknown method -> error -32601
       h. `test_invalid_json_returns_parse_error` — send malformed JSON -> error -32700
       i. `test_all_responses_have_jsonrpc_field` — verify every non-None response has "jsonrpc": "2.0"
       j. `test_invalid_params_on_initialize` — send initialize with invalid params (e.g., missing protocolVersion) -> error -32602

       For each test, construct raw JSON strings and call handler.handle_json(), then parse the response string back to verify fields.
  </action>
  <verify>
    Run `cargo test --lib mcp::handler` — all protocol tests pass.
    Run `cargo clippy -- -D warnings` — no warnings.
    Run `cargo check` — clean compilation.
  </verify>
  <done>
    - McpHandler holds Arc<Registry>, MatchConfig, and AtomicBool for init state
    - handle_json is the single entry point: raw JSON string in, Option<String> out
    - Batch rejection at raw JSON level (checks for array before parsing)
    - Notifications silently ignored (no id -> return None)
    - Initialize handshake sets flag and returns correct MCP response
    - Pre-init requests rejected with -32002
    - Unknown methods return -32601
    - Invalid JSON returns -32700
    - All 10+ protocol compliance tests pass
    - Stub methods ready for Plan 02 tool implementations
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with no errors
2. `cargo test --lib mcp` passes all handler tests
3. `cargo clippy -- -D warnings` — no warnings
4. McpHandler::new() constructs with registry and match config
5. handle_json correctly routes all JSON-RPC methods
6. Protocol error codes match spec: -32700, -32600, -32601, -32602, -32002
</verification>

<success_criteria>
- JSON-RPC 2.0 types properly serialize/deserialize with serde
- McpHandler enforces initialize-before-tools handshake
- Batch requests rejected with -32600
- Notifications produce no response
- Initialize returns correct MCP protocol response
- All protocol compliance tests pass
- Stubs ready for tool implementation in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-protocol-implementation/03-01-SUMMARY.md`
</output>
