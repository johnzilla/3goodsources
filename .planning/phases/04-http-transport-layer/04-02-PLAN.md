---
phase: 04-http-transport-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Server starts on port 3000 (or PORT env var) and logs the address"
    - "POST /mcp accepts JSON-RPC requests and returns valid MCP responses"
    - "GET /health returns 200 OK with JSON containing status and version"
    - "GET /registry returns full registry JSON with all categories"
    - "CORS headers are present on responses (Access-Control-Allow-Origin)"
    - "Malformed JSON to POST /mcp returns JSON-RPC parse error (-32700)"
    - "Server handles MCP notifications (returns 204 No Content)"
  artifacts:
    - path: "src/main.rs"
      provides: "Complete server startup with axum::serve"
      contains: "axum::serve"
  key_links:
    - from: "src/main.rs"
      to: "src/server.rs"
      via: "build_router called with Arc<AppState>"
      pattern: "build_router"
    - from: "src/main.rs"
      to: "src/mcp/handler.rs"
      via: "McpHandler::new constructed and passed to AppState"
      pattern: "McpHandler::new"
    - from: "src/main.rs"
      to: "tokio::net::TcpListener"
      via: "TcpListener::bind then axum::serve"
      pattern: "TcpListener::bind"
---

<objective>
Wire main.rs to construct AppState, build the router, bind to the configured port, and start the axum server. Transform the application from "load and exit" to "load and serve."

Purpose: This is the integration point that connects all prior phases into a running HTTP server. After this plan, the 3GS MCP server is fully functional over HTTP.

Output: A running server that passes all 6 phase success criteria when tested with curl.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-http-transport-layer/04-RESEARCH.md
@.planning/phases/04-http-transport-layer/04-01-SUMMARY.md

@src/main.rs
@src/server.rs
@src/config.rs
@src/mcp/handler.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire main.rs to start axum server</name>
  <files>src/main.rs</files>
  <action>
Replace the current main() function body to:

1. Keep existing: Config::load(), init_logging(), MatchConfig::load() + validate()
2. Change registry loading to wrap in Arc: `let registry = Arc::new(registry::load(&config.registry_path).await?);`
3. Create McpHandler: `let mcp_handler = mcp::McpHandler::new(Arc::clone(&registry), match_config);`
4. Create AppState: `let app_state = Arc::new(server::AppState { mcp_handler, registry });`
5. Build router: `let app = server::build_router(app_state);`
6. Bind and serve:
```rust
let addr = format!("0.0.0.0:{}", config.port);
tracing::info!(port = config.port, "Server listening on {}", addr);
let listener = tokio::net::TcpListener::bind(&addr).await?;
axum::serve(listener, app).await?;
```

Add necessary imports at top of main.rs: `use std::sync::Arc;`

The `mod server;` declaration should already exist from Plan 01. Keep all existing module declarations (config, error, matcher, mcp, pubky, registry).

Important: The tracing::info! for starting server should come AFTER successful registry/config loading but BEFORE listener bind, so users see the configured port. The existing "Starting 3GS server" log can stay as-is or be removed (the listen log replaces it).

Do NOT change init_logging function -- it stays as-is.
  </action>
  <verify>
Run `cargo build` to confirm compilation. Then test the running server:

1. Start server in background: `cargo run &`
2. Wait 2 seconds for startup
3. Test health: `curl -s http://localhost:3000/health` -- expect {"status":"ok","version":"0.1.0"}
4. Test registry: `curl -s http://localhost:3000/registry | head -c 200` -- expect registry JSON
5. Test MCP initialize: `curl -s -X POST http://localhost:3000/mcp -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-11-25","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'` -- expect protocolVersion in response
6. Test malformed JSON: `curl -s -X POST http://localhost:3000/mcp -d '{bad json}'` -- expect error code -32700
7. Test CORS: `curl -s -I -X OPTIONS http://localhost:3000/mcp` -- expect access-control-allow-origin header
8. Kill background server

All curl commands must succeed.
  </verify>
  <done>Server starts on configured port, all 3 endpoints respond correctly, CORS headers present, malformed JSON returns parse error. `cargo test` still passes all existing tests.</done>
</task>

<task type="auto">
  <name>Task 2: Update .env.example and verify full integration</name>
  <files>.env.example</files>
  <action>
Ensure .env.example has PORT documented (may already exist from Plan 01). If not, add:

```
PORT=3000
```

Run the full test suite with `cargo test` to verify no regressions. All existing MCP handler tests, registry tests, and matcher tests must pass.

Run `cargo clippy` if available to catch any warnings in the new code.
  </action>
  <verify>
`cargo test` passes all tests. `.env.example` contains PORT=3000. `cargo clippy` has no errors (warnings acceptable for existing code).
  </verify>
  <done>.env.example is complete. Full test suite passes. No regressions from HTTP transport integration.</done>
</task>

</tasks>

<verification>
Start the server and run these 6 checks corresponding to phase success criteria:

1. **Server starts on port 3000:** `cargo run` logs "Server listening on 0.0.0.0:3000"
2. **POST /mcp works:** curl POST with initialize request returns protocolVersion and serverInfo
3. **GET /health returns 200:** curl returns `{"status":"ok","version":"0.1.0"}`
4. **GET /registry returns JSON:** curl returns full registry with version, curator, categories
5. **CORS headers present:** OPTIONS request returns access-control-allow-origin header
6. **Malformed JSON handled:** POST /mcp with `{bad}` returns JSON-RPC error code -32700

All `cargo test` existing tests pass (zero regressions).
</verification>

<success_criteria>
- Server starts and accepts HTTP connections on configured port
- All three endpoints respond with correct status codes and content types
- MCP JSON-RPC protocol works end-to-end over HTTP
- CORS preflight (OPTIONS) returns permissive headers
- Malformed requests get proper error responses
- Full existing test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-http-transport-layer/04-02-SUMMARY.md`
</output>
