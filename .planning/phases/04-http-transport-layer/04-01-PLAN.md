---
phase: 04-http-transport-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config.rs
  - src/server.rs
autonomous: true

must_haves:
  truths:
    - "Server module compiles with axum route handlers for /mcp, /health, /registry"
    - "Config struct includes PORT with default 3000"
    - "CORS layer is permissive for MVP cross-origin access"
    - "POST /mcp handler delegates to McpHandler::handle_json and returns JSON responses"
    - "GET /health returns 200 OK with version from CARGO_PKG_VERSION"
    - "GET /registry returns raw registry JSON with application/json content-type"
    - "MCP notifications (handle_json returns None) map to HTTP 204 No Content"
  artifacts:
    - path: "Cargo.toml"
      provides: "axum 0.8 and tower-http 0.6 dependencies"
      contains: "axum"
    - path: "src/config.rs"
      provides: "PORT environment variable support"
      contains: "port"
    - path: "src/server.rs"
      provides: "AppState, route handlers, router builder"
      exports: ["AppState", "build_router"]
  key_links:
    - from: "src/server.rs"
      to: "src/mcp/handler.rs"
      via: "McpHandler::handle_json called from mcp_endpoint"
      pattern: "handle_json"
    - from: "src/server.rs"
      to: "src/registry/types.rs"
      via: "Registry serialized in registry_endpoint"
      pattern: "serde_json::to_string"
    - from: "src/server.rs"
      to: "tower-http"
      via: "CorsLayer::permissive applied to router"
      pattern: "CorsLayer::permissive"
---

<objective>
Create the HTTP server module with axum route handlers, shared state, and CORS middleware for all three endpoints (POST /mcp, GET /health, GET /registry).

Purpose: Provides the HTTP transport layer that exposes existing MCP protocol logic over HTTP. The route handlers are thin wrappers around already-tested McpHandler and Registry types.

Output: Compilable server module with AppState, three route handlers, and a router builder function ready for main.rs integration.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-http-transport-layer/04-RESEARCH.md

@src/mcp/handler.rs
@src/registry/types.rs
@src/config.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HTTP dependencies and PORT config</name>
  <files>Cargo.toml, src/config.rs, .env.example</files>
  <action>
Add axum and tower-http to Cargo.toml dependencies:

```toml
axum = "0.8"
tower-http = { version = "0.6", features = ["cors"] }
```

Add PORT field to Config struct in src/config.rs:

```rust
/// Server port. Defaults to 3000. Set via PORT env var (required by Render).
#[serde(default = "default_port")]
pub port: u16,
```

Add the default function:

```rust
fn default_port() -> u16 {
    3000
}
```

Update .env.example to include PORT=3000.

Do NOT change any existing fields or behavior in Config.
  </action>
  <verify>Run `cargo check` to confirm dependencies resolve and Config compiles.</verify>
  <done>Cargo.toml has axum 0.8 and tower-http 0.6 with cors feature. Config struct has port field with default 3000. .env.example shows PORT.</done>
</task>

<task type="auto">
  <name>Task 2: Create server module with AppState, routes, and CORS</name>
  <files>src/server.rs, src/main.rs</files>
  <action>
Create src/server.rs with the following:

**AppState struct:**
```rust
pub struct AppState {
    pub mcp_handler: McpHandler,
    pub registry: Arc<Registry>,
}
```

**build_router function:**
```rust
pub fn build_router(state: Arc<AppState>) -> Router {
    Router::new()
        .route("/mcp", post(mcp_endpoint))
        .route("/health", get(health_endpoint))
        .route("/registry", get(registry_endpoint))
        .layer(CorsLayer::permissive())
        .with_state(state)
}
```

**Three route handlers:**

1. `mcp_endpoint` - Takes `State(state): State<Arc<AppState>>` and `body: String` (body MUST be last parameter). Calls `state.mcp_handler.handle_json(&body)`. On `Some(json)`, return `(StatusCode::OK, [(header::CONTENT_TYPE, "application/json")], json)`. On `None`, return `(StatusCode::NO_CONTENT, [(header::CONTENT_TYPE, "application/json")], String::new())`.

2. `health_endpoint` - No state needed. Return `Json(json!({"status": "ok", "version": env!("CARGO_PKG_VERSION")}))` using axum's `Json` extractor.

3. `registry_endpoint` - Takes `State(state): State<Arc<AppState>>`. Serialize `state.registry` with `serde_json::to_string_pretty`. Return with StatusCode::OK and application/json content-type. If serialization fails, return StatusCode::INTERNAL_SERVER_ERROR with error message.

Add `mod server;` to src/main.rs (just the module declaration, do NOT change anything else in main.rs yet -- Plan 02 handles main.rs wiring).

Important details:
- Use `axum::routing::{get, post}` for route methods
- Use `axum::extract::State` for state extraction
- Use `axum::http::{StatusCode, header}` for response construction
- Use `axum::Json` and `serde_json::json!` for health endpoint
- Use `tower_http::cors::CorsLayer` for CORS
- All handler functions are `async fn` (even if body is sync, axum requires async)
- String extractor consumes body -- must be LAST parameter after State
  </action>
  <verify>Run `cargo check` to confirm the module compiles. Run `cargo test` to confirm existing tests still pass (no regressions).</verify>
  <done>src/server.rs exists with AppState, build_router, and three route handlers. Module declared in main.rs. All existing tests pass. `cargo check` succeeds.</done>
</task>

</tasks>

<verification>
1. `cargo check` succeeds with no errors
2. `cargo test` passes all existing tests (no regressions)
3. src/server.rs contains AppState struct, build_router function, and three async handler functions
4. Cargo.toml includes axum = "0.8" and tower-http with cors feature
5. Config struct has port field with default 3000
</verification>

<success_criteria>
- axum 0.8 and tower-http 0.6 compile successfully
- Server module has all three route handlers ready for integration
- CORS middleware configured as permissive
- Config supports PORT env var with 3000 default
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-http-transport-layer/04-01-SUMMARY.md`
</output>
