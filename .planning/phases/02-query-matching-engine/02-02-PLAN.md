---
phase: 02-query-matching-engine
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/matcher/scorer.rs
  - src/matcher/mod.rs
autonomous: true

must_haves:
  truths:
    - "Query 'learn rust' matches rust-learning category"
    - "Query 'bitcoin node' matches bitcoin-node-setup category"
    - "Query 'email server' matches self-hosted-email category"
    - "Queries below 0.4 threshold return BelowThreshold error with closest slug, score, and all slugs"
    - "Keyword boosting increases scores when query contains slug terms"
    - "match_query returns single best match (highest scorer wins, no ambiguity)"
  artifacts:
    - path: "src/matcher/scorer.rs"
      provides: "Fuzzy + keyword scoring and match_query public API"
      exports: ["match_query", "MatchResult"]
    - path: "src/matcher/mod.rs"
      provides: "Re-exports scorer types and function"
      contains: "pub use scorer"
  key_links:
    - from: "src/matcher/scorer.rs"
      to: "strsim"
      via: "strsim::normalized_levenshtein for fuzzy scoring"
      pattern: "normalized_levenshtein"
    - from: "src/matcher/scorer.rs"
      to: "src/matcher/normalize.rs"
      via: "normalize_text called on query and patterns"
      pattern: "normalize::normalize_text"
    - from: "src/matcher/scorer.rs"
      to: "src/matcher/config.rs"
      via: "MatchConfig provides threshold and weights"
      pattern: "config.match_threshold"
    - from: "src/matcher/scorer.rs"
      to: "src/registry/types.rs"
      via: "Registry and Category types for category iteration"
      pattern: "Registry"
---

<objective>
Implement the scoring engine and match_query() public API using TDD.

Purpose: This is the core business logic of Phase 2 — the fuzzy + keyword scoring that maps queries to categories. TDD ensures all 5 success criteria are met with tests written before implementation.
Output: Working match_query() function that passes all success criteria tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-query-matching-engine/02-CONTEXT.md
@.planning/phases/02-query-matching-engine/02-RESEARCH.md
@.planning/phases/02-query-matching-engine/02-01-SUMMARY.md
@src/registry/types.rs
@src/matcher/normalize.rs
@src/matcher/config.rs
@src/matcher/error.rs
@src/matcher/mod.rs
@registry.json
</context>

<feature>
  <name>Query Matching Engine (scorer + match_query)</name>
  <files>src/matcher/scorer.rs, src/matcher/mod.rs</files>
  <behavior>
    The match_query function takes a query string, a Registry reference, and a MatchConfig reference. It returns either a MatchResult (slug + score of best match) or a MatchError.

    **Pipeline:** normalize query -> score all categories -> select best -> threshold check

    **Scoring per category (weighted sum):**
    - Fuzzy score: Best normalized_levenshtein score across all match surfaces (query_patterns, slug with hyphens replaced by spaces, display name lowercased). Normalize patterns with normalize_text before comparing.
    - Keyword score: Fraction of slug terms (split on hyphen) found in the query. E.g., query "bitcoin node" against slug "bitcoin-node-setup" -> 2/3 terms found = 0.667.
    - Combined: (fuzzy_weight * fuzzy_score) + (keyword_weight * keyword_score), clamped to [0.0, 1.0]

    **Match surfaces for fuzzy scoring (do NOT match against description):**
    - Each query_pattern in category.query_patterns (normalized with normalize_text)
    - Category slug with hyphens replaced by spaces (e.g., "bitcoin-node-setup" -> "bitcoin node setup")
    - Category name lowercased (e.g., "Bitcoin Node Setup" -> "bitcoin node setup")

    **Cases (with default config: threshold=0.4, fuzzy=0.7, keyword=0.3):**

    Input: "learn rust" -> MatchResult { slug: "rust-learning", score: >0.4 }
    Input: "bitcoin node" -> MatchResult { slug: "bitcoin-node-setup", score: >0.4 }
    Input: "email server" -> MatchResult { slug: "self-hosted-email", score: >0.4 }
    Input: "quantum physics" -> MatchError::BelowThreshold { closest_slug: (some slug), closest_score: <0.4, all_slugs: (10 slugs) }
    Input: "" -> MatchError::EmptyQuery
    Input: "the a an" -> MatchError::QueryAllStopWords

    **Keyword boosting verification:**
    - Score for "bitcoin node" with keyword boost should be higher than fuzzy-only score
    - A query containing exact slug terms gets keyword boost; a query with no slug terms gets 0.0 keyword score

    **MatchResult struct:**
    ```rust
    pub struct MatchResult {
        pub slug: String,
        pub score: f64,
        pub category: Category,  // Clone of the matched category
    }
    ```
  </behavior>
  <implementation>
    **RED phase — Write failing tests first:**

    Create `src/matcher/scorer.rs` with:
    - MatchResult struct definition
    - match_query function signature (can return unimplemented!() initially)
    - Internal helper signatures: calculate_fuzzy_score, calculate_keyword_score, calculate_score

    Write tests in `#[cfg(test)] mod tests`:
    1. `test_learn_rust_matches_rust_learning` — "learn rust" -> slug "rust-learning", score > 0.4
    2. `test_bitcoin_node_matches_bitcoin_node_setup` — "bitcoin node" -> slug "bitcoin-node-setup", score > 0.4
    3. `test_email_server_matches_self_hosted_email` — "email server" -> slug "self-hosted-email", score > 0.4
    4. `test_below_threshold_returns_error` — "quantum physics supercollider" -> BelowThreshold error with all_slugs.len() == 10
    5. `test_keyword_boost_increases_score` — compare score with keyword_weight=0.3 vs keyword_weight=0.0 for a query containing slug terms; boosted score must be higher
    6. `test_empty_query_returns_error` — "" -> EmptyQuery
    7. `test_all_stop_words_returns_error` — "the a an" -> QueryAllStopWords
    8. `test_best_match_wins` — query that could match multiple categories returns highest scorer

    Use a test helper function that loads registry.json from disk (use `include_str!` or `std::fs::read_to_string` with path relative to project root). Create default MatchConfig in tests.

    Use `approx::assert_relative_eq!` for any float comparisons. Use pattern matching on MatchError variants to assert error types.

    **GREEN phase — Implement to pass:**

    1. `calculate_fuzzy_score(query: &str, slug: &str, category: &Category) -> f64`:
       - Compare normalized query against each normalize_text(pattern) in query_patterns using normalized_levenshtein
       - Compare against slug with hyphens replaced by spaces
       - Compare against category.name.to_lowercase()
       - Return the maximum score across all surfaces

    2. `calculate_keyword_score(query: &str, slug: &str) -> f64`:
       - Split slug on hyphens to get slug terms
       - Count how many slug terms appear in the query (substring match using str::contains)
       - Return fraction: matches / total_slug_terms

    3. `calculate_score(query: &str, slug: &str, category: &Category, config: &MatchConfig) -> f64`:
       - Call calculate_fuzzy_score and calculate_keyword_score
       - Return weighted sum: (config.match_fuzzy_weight * fuzzy) + (config.match_keyword_weight * keyword)
       - Clamp result to [0.0, 1.0] using .min(1.0)

    4. `pub fn match_query(query: &str, registry: &Registry, config: &MatchConfig) -> Result<MatchResult, MatchError>`:
       - Normalize query with normalize_text (propagate EmptyQuery/QueryAllStopWords errors)
       - Score all categories, collect (slug, score, category) tuples
       - Sort by score descending
       - If best score >= config.match_threshold: return Ok(MatchResult { slug, score, category })
       - If best score < threshold: return Err(BelowThreshold { threshold, closest_slug, closest_score, all_slugs })

    5. Update `src/matcher/mod.rs`:
       - Add `pub mod scorer;`
       - Add `pub use scorer::{match_query, MatchResult};`

    **REFACTOR phase:**
    - Clean up any code duplication between fuzzy score calculations
    - Ensure all public types have doc comments
    - Run clippy: `cargo clippy -- -D warnings`
  </implementation>
</feature>

<verification>
1. `cargo test --lib matcher::scorer` — all 8 scorer tests pass
2. `cargo test --lib matcher` — all tests (normalize + scorer) pass
3. `cargo clippy -- -D warnings` — no warnings
4. `cargo check` — clean compilation
5. Specific success criteria verified:
   - "learn rust" -> rust-learning ✓
   - "bitcoin node" -> bitcoin-node-setup ✓
   - "email server" -> self-hosted-email ✓
   - Below threshold returns helpful error ✓
   - Keyword boosting increases scores ✓
</verification>

<success_criteria>
- match_query("learn rust", ...) returns MatchResult with slug "rust-learning"
- match_query("bitcoin node", ...) returns MatchResult with slug "bitcoin-node-setup"
- match_query("email server", ...) returns MatchResult with slug "self-hosted-email"
- Below-threshold query returns BelowThreshold error with closest_slug, closest_score, and 10 category slugs
- Keyword boosting demonstrably increases score for queries containing slug terms
- All tests pass, clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-query-matching-engine/02-02-SUMMARY.md`
</output>
